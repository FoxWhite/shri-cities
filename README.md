Ошибка происходит из-за неверного использования замыкания (closure). Замыкания используют __ссылки__ на внешние переменные, и связывают содержащиеся по ним значения в последний момент:  фактически, в тот момент, когда внутренняя функция в замыкании уже возвращает значение. Поэтому в данном (весьма типичном)  случае к "моменту замыкания" итератор ```i``` уже прошел от 0 до 2,  на него трижды создалась ссылка, которая в итоге во всех случаях привела на значение 2. Таким образом ```request``` все три раза получился равен *'/populations'*, ну и дальше всё пошло не так (в ```responses``` всегда перезаписывается результат одного и того же ```request```, количество ключей в нем таким образом никогда не достигает трёх, и т. д.).

Существует несколько решений для исправления ситуации:

1. Самое простое - передавать в ```callback``` не только ```result```, но и ```request```, который таким образом будет сохраняться с каждой итерации. 
Функцию ```callback()``` тогда можно вынести из цикла
http://jsfiddle.net/Belegor/e4bxc7ng/3/

2. Еще один способ - упаковать все в функцию ```sendReq()```, принимающую итератор в качестве аргумента, и вызывать в цикле её. Такой аргумент будет сохраняться.
http://jsfiddle.net/Belegor/kve5s2y6/

3. Начиная с IE 9 можно использовать метод ```forEach()```, который позволяет иметь отдельное замыкание для каждой итерации. Так что можно заменить  цикл *for* на него.
http://jsfiddle.net/Belegor/judt43b5/

4. Самый современный способ решения этой проблемы доступен благодаря спецификации ES6. Если использовать новый оператор ```let``` для определения итератора в цикле ```(for let i...)```, такой цикл будет создавать новую связь для ```i``` в каждой итерации. Таким образом достаточно лишь заменить  ```for (var i = 0; i < 3; i++)``` на ```for (let i = 0; i < 3; i++)```, 
а также ```responses[request]```  на ```responses[requests[i]]```, и всё будет работать*.       
http://www.es6fiddle.net/iddd609l/

\* Пока что, к сожалению, только с применением транспайлеров, таких как babel. Зато прогрессивно.

Потенциальным источником ошибок может являться использование глобальных переменных (i,j, K) в итераторах циклов; 
также отсутствуют фигурные скобки у тела цикла ```for in``` (хотя он в данный момент и содержит всего одну строку, и вообще это касается скорее принятых стилей). К слову о стиле — неплохо было бы называть переменные семантически более читаемо (больше одной буквы в названии) и не отбирать хлеб у uglify.js :)


## Задание 2
http://jsfiddle.net/Belegor/jvqehojx/       
Для реализации второго задания написаны три функции. Все они обращаются к уже заполненной глобальной переменной responses:   

```cityOrCountry()``` - выдает пользователю prompt и решает, ввел ли он название страны или города. Затем обращается к вспомогательным функциям, считающим население.     
Данную функцию можно было бы упростить, убрав цикл по странам: в объектах городов уже есть как имена стран, так и имена городов. Поскольку мы все равно считаем население только у имеющихся городов, можно учитывать только страны, у которых есть города. Тем не менее, я решил оставить оба цикла, потому что такое упрощение может сыграть злую шутку при расширении функционала.   

```getCountryPop()``` заводит массив городов для данной страны и возвращает сумму их популяций, полученных с помошщью функций ```getCityPop()``` 
